import asteval
import six

import dripline
#import dragonfly

#import scipy
import scipy.constants as consts
import socket as skt
import numpy as np
import math

import logging
logger = logging.getLogger('dragonfly.custom.sag_interface')

class SAGCoordinator(dripline.core.Endpoint):
    '''
    Coordinated interactions with all instruments within the broader sag system.
    Provides a single point of contact and uniform interface to the SAG.
    '''
    def __init__(self, enable_output_sets=None, disable_output_sets=None, sag_injection_sets=None, update_waveform_sets=None, sag_arb_waveform_name=None, switch_endpoint=None, extra_logs=[], state_extra_logs={}, f_stan=60, f_rest=650000000, line_shape='maxwellian', **kwargs):
        '''
        enable_output_sets: (list) - a sequence of endpoints and values to set to configure the system to be ready to start output of a signal
        disable_output_sets: (list) - a sequence of endpoints and values to set to configure the system to not produce any output
        sag_injection_sets: (list) - a sequence of endpoints to set to create a particular injection; configuration determined from asteval of input values
        update_waveform_sets: (list) - a sequence of endpoints to set to update the wave form to be generated by the ARB
        switch_endpoint: (string) - name of the endpoint used for switching the signal path into the weak port
        extra_logs: (list) - list of endpoint names to cmd `scheduled_action` (to trigger a log) whenever the SAG is configured
        state_extra_logs: (dict) - dict with keys being valid switch_endpoint states (string) and values being a list of extra sensors to log when entering that state.
        f_stan: (float) - value of the frequency seperation between, in Hz
        f_rest: (float) - value of the axion rest mass frequency for time series generation, in Hz
        line_shape: (string) - name of the axion line shape model to be used
        '''
        dripline.core.Endpoint.__init__(self, **kwargs)

        self.enable_output_sets = enable_output_sets
        self.disable_output_sets = disable_output_sets
        self.sag_injection_sets = sag_injection_sets
        self.update_waveform_sets = update_waveform_sets
        self.sag_arb_waveform_name = sag_arb_waveform_name
        self.switch_endpoint = switch_endpoint
        self.extra_logs = extra_logs
        self.state_extra_logs = state_extra_logs
        

        self.evaluator = asteval.Interpreter()

        # attributes for line shape generation into the waveform generator (33220A)
        self.tscaled = []
        self.tseries = []
        self.spectrum = []
        self.re_tseries = []
        self.scale = []
        self.f_stan = f_stan
        self.f_rest = f_rest
        self.line_shape = line_shape
        self.N = 65536
        self.n = 65000
        self.h = consts.Planck #J/Hz
        self.h_eV = consts.physical_constants['Planck constant in eV s'][0] #eV/Hz
        self.eV = consts.physical_constants['joule-electron volt relationship'][0] #6.24e18
        self.c = (consts.c) *10**-3 #km/s
        self.v_bar = (230/0.85) #km/s
        self.r = 0.85
        self.alpha =  0.36 #+/- 0.13 from Lentz et al. 2017
        self.beta = 1.39 #+/- 0.28 from Lentz et al. 2017
        self.T = 4.7*(10**(-7)) #+/-1.9 from Lentz et al. 2017

    def _do_set_collection(self, these_sets, values):
        '''
        A utility method for processing a list of sets
        '''
        set_list = []
        # first parse all string evaluations, make sure they all work before doing any actual setting
        for a_calculated_set in these_sets:
            logger.debug("dealing with calculated_set: {}".format(a_calculated_set))
            if len(a_calculated_set) > 1:
                raise dripline.core.DriplineValueError('all calculated sets must be a single entry dict')
            [(this_endpoint,set_str)] = six.iteritems(a_calculated_set)
            logger.debug('trying to understand: {}->{}'.format(this_endpoint, set_str))
            this_value = set_str
            if '{' in set_str and '}' in set_str:
                try:
                    this_set = set_str.format(**values)
                except KeyError as e:
                    raise dripline.core.DriplineValueError("required parameter, <{}>, not provided".format(e.message))
                logger.debug('substitutions make that RHS = {}'.format(this_set))
                this_value = self.evaluator(this_set)
                logger.debug('or a set value of {}'.format(this_value))
            set_list.append((this_endpoint, this_value))
        # now actually try to set things
        for this_endpoint, this_value in set_list:
            #logger.info("if I weren't a jerk, I'd do:\n{} -> {}".format(this_endpoint, this_value))
            logger.info("setting endpoint '"+str(this_endpoint)+"' with value: "+str(this_value)) 
            self.provider.set(this_endpoint, this_value)
            


    #def _do_log_noset_sensors(self):
    def _do_extra_logs(self, sensors_list):
        '''
        Send a scheduled_action (log) command to configured list of sensors (this is for making sure we log everything
        that should be recorded on each injection, but which is not already/automatically logged by a log_on_set action)
        '''
        logger.info('triggering logging of the following sensors: {}'.format(sensors_list))
        for a_sensor in sensors_list:
            self.provider.cmd(a_sensor, 'scheduled_action')

    def update_state(self, new_state):
        # do universal extra logs
        self._do_extra_logs(self.extra_logs)
        # do state-specific extra logs
        if new_state in self.state_extra_logs:
            self._do_extra_logs(self.state_extra_logs[new_state])
        else:
            logger.warning('state <{}> does not have a state-specific extra logs list, please create one (it may be empty)'.format(new_state))
        # actually set to the new state
        if new_state == 'term':
            self.do_disable_output_sets()
            self.provider.set(self.switch_endpoint, "term")
        elif new_state == 'sag':
            self.do_enable_output_sets()
            self.provider.set(self.switch_endpoint, "sag")
        elif new_state == 'vna':
            # set the switch
            self.provider.set(self.switch_endpoint, "vna")
            # disable outputs
            self.do_disable_output_sets()
        elif new_state == 'locking':
            raise dripline.core.DriplineValueError('locking state is not currently supported')
        else:
            raise dripline.core.DriplineValueError("don't know how to set the SAG state to <{}>".format(new_state))

    def do_enable_output_sets(self):
        logger.info('enabling lo outputs')
        self._do_set_collection(self.enable_output_sets, {})

    def do_disable_output_sets(self):
        logger.info('disabling lo outputs')
        self._do_set_collection(self.disable_output_sets, {})

    def configure_injection(self, **parameters):
        '''
        parameters: (dict) - keyworded arguments are available to all sensors as named substitutions when calibrating
        '''
        logger.info('in configure injection')
        # set to state 'sag' (which enables output)
        self.update_state("sag")
        # to extra sets calculated from input parameters
        self._do_set_collection(self.sag_injection_sets, parameters)

    def update_waveform(self, **parameters):
        logger.info('in update waveform')
        self.f_rest = float(parameters['f_rest'])
        self.line_shape = str(parameters['shape_type'])
        self.send_thru_sag_arb_service = bool(parameters['use_sag_arb_service'])
        logger.info('send_thru_sag_arb_service set to {}'.format(self.send_thru_sag_arb_service))
    
        def get_du():

            self.m_a = (self.h*self.f_rest)/(self.c**2) #J/c^2
            if self.line_shape == 'max_2017':
                self.m_a = self.m_a * self.eV #eV/c^2
                self.m_a = self.m_a * self.c**2
            else:
                pass
            self.du = (self.h*self.f_stan)/((self.m_a*(self.v_bar**2))/2) 

        
        def max_term(x,i):
            term = ((((i-self.n)*self.f_stan)*self.h_eV)/(self.m_a*self.T))**x
            return term
        
        def normShape(sampleArray):
            # returns unit normalized sample array by integrating array elements (sum) and dividing by the total
            total = sampleArray.sum()
            return sampleArray/total
        
        def bigFlows(fmass):
            
            # relative densities for each flow
            gram2GeV = 1.e-3*consts.physical_constants["kilogram-electron volt relationship"][0]*1.e-9
            rhoBig = 2.e-23*gram2GeV # GeV/cc
            rhoLittle = 2.e-24*gram2GeV
            rhoUp = 9.6e-24*gram2GeV
            rhoDown = 8.4e-24*gram2GeV
            # central velocities in Galactic center fixed frame
            # using galactic cylindrical coordinates (vr,vphi,vz)
            vBig = np.array((-104.4, 509.4, 6.1) )# km/s
            vLittle = np.array((-0.2, 530.0, 4.5))
            vUp = np.array((-115.3,505.1,44.8))
            vDown = np.array((-116.4,505.4,-38.1))
            # relative velocity of Sun to MW center, in galactic cylindrical basis
            vSun = np.array((12.9, 245.6, 7.78)) # km/s s.galcen_v_sun # note thqat the x,y,z frame of icrs identifies with the galactic cylindrical coordinates
            # speed dispersion of each flow
            dv = 70. #m/s
            # boosted central velocity into sun-stationary frame
            vBigSol = vBig - vSun
            vLittleSol = vLittle - vSun
            vUpSol = vUp - vSun
            vDownSol = vDown - vSun
            
            # determine central frequency for  each flow
            fBig = fmass*(1. + 0.5*np.linalg.norm(vBigSol)**2/self.c**2)
            fLittle = fmass*(1. + 0.5*np.linalg.norm(vLittleSol)**2/self.c**2)
            fUp = fmass*(1. + 0.5*np.linalg.norm(vUpSol)**2/self.c**2)
            fDown = fmass*(1. + 0.5*np.linalg.norm(vDownSol)**2/self.c**2)
        
            
            # find index of bin close to each flow
            idxBig = self.n+math.ceil((-self.f_rest+fBig)/self.f_stan)
            idxLittle = self.n+math.ceil((-self.f_rest+fLittle)/self.f_stan)
            idxUp = self.n+math.ceil((-self.f_rest+fUp)/self.f_stan)
            idxDown = self.n+math.ceil((-self.f_rest+fDown)/self.f_stan)
            
            # set 1-bin amplitude using density of flow
            amps = np.zeros(self.N)
            amps[idxBig] += rhoBig
            amps[idxLittle] += rhoLittle
            amps[idxUp] += rhoUp
            amps[idxDown] += rhoDown
            
            # normalize total shape
            amps = normShape(amps)
            return amps
        
        def MaxBoltz(E,vboost,beta):
            # normalized isotropic 3D gaussian with speed argument
            vb = np.linalg.norm(vboost)
            amp = 2*(beta/np.pi)**(0.5)/vb*np.sinh(2*beta*np.sqrt(2*E)*vb)*np.exp(-2*E*beta-beta*vb**2)
            return amp
        
        def BoseLobe(E,vboost,beta,vMean):
            # normalized isotropic 1D gaussian with speed argument
            vbplus = vboost + vMean
            vbminus = vboost - vMean
            vb = np.linalg.norm(vboost)
            amp = (beta/np.pi)**(-0.5)*np.exp(-2*E*beta)
            return amp
        
        def Lentz2020Shape(Df,Corr):
            # sets the line shape result of Lentz 2020 "Axion Structure Formation II"
            vVir = 130./self.c # fraction of c, virial speed of halo. Estimated by narrowed lineshape of Lentz et al 2017
            beta = 1/vVir**2# effective temperature of halo central feature
            vboost = np.array((0.,230./self.c, 0.)) # fraction of c, boost in the azimuthal direction of the glactic frame
            
            m = self.f_rest*self.h_eV # rest mass in eV
            E = self.h_eV*Df/m # kinetic energy (energy above rest mass)
            v = np.sqrt(2*E) # speed, not velocity, of axion at that energy
            
            centralGauss = MaxBoltz( E, vboost, beta) #4*np.pi*v**2*v*self.Gaussian3D(v,vboost,beta)*self.c**2 # gives the differential probability amplitude
            #print(centralGauss)
            vMeanBose = np.array((2.5*vVir,0,0)) # mean speed for Bose lobe, along +/- radial direction
            betaBose = beta*4
            
            BoseLobe = 0.25*(MaxBoltz(E, vboost-vMeanBose, betaBose) + MaxBoltz(E, vboost+vMeanBose, betaBose)) #0.2*v*self.Gaussian1D(v-vMeanBose,vboost,betaBose) # normalized Bose lobe feature, assuming two radial velocity only and lobes are well separated 
            
            peakFunc = lambda x: 0.45 + 0.55*x**2
            # superpose two contributions, using a correlation quadratic weighting 
            pF = peakFunc(Corr)
            GaussContr = pF*centralGauss
            BoseContr = (1.-pF)*BoseLobe
            amp = GaussContr + BoseContr
            return amp
    
    
        def BoseDM(fmass,Corr):
            # set 1-bin amplitude using density of flow
            amps = np.zeros(self.N)
            for i in range(self.n,self.N):
                amps[i] = Lentz2020Shape((i-self.n)*self.f_stan, Corr)
            # normalize total shape
            amps = normShape(amps)
            return amps    

        def SAG_Spec():
            '''
            This function generates the distribution function in terms of the axion kinetic energy   measured in the experiment's laboratory (Turner 1990 [5b]).
            u = (i-n)du where u dimensionless form of axion KE in lab frame
            r = ratio of the velocity of the Sun through the Galaxy to the rms halo velocity
            max_2017 = N-body maxwellian form from Lentz et al. 2017
            big_flows = Caustic ring flows (n=4?) from Pierre Sikivie halo model
            bose_nbody_2020 = Bose N-body halo model from Lentz et al. 2020
            maxwellian = maxwellian form from Turner et al. 1990
            '''
            spec=np.zeros(self.N) 
            if self.line_shape == 'max_2017':
                for i in range(self.n, self.N):
                    spec[i] = max_term(self.alpha,i)*math.exp(-(max_term(self.beta,i)))
            elif self.line_shape == 'big_flows':
                spec = bigFlows(self.f_rest)
            elif self.line_shape == 'bose_nbody_2020':
                spec = BoseDM(self.f_rest,0.0)
            else:  # maxwellian
                for i in range(self.n, self.N):
                    spec[i]=np.sqrt(np.sqrt(3/(2*np.pi))/self.r*np.exp(-1.5*(self.r*self.r+(i-self.n)*self.du))*np.sinh(3*self.r*np.sqrt((i-self.n)*self.du)))


            spec_norm = np.array(spec)/sum(spec)
            self.spectrum = list(spec_norm)

        def FourierTrans():
            N=np.size(self.spectrum) 
            tseries=np.fft.ifft(self.spectrum) #compute the one-dimensional inverse discrete Fourier Transform from frequency domain to time domain
            
            tseries=tseries.real 
            
            re_tseries=np.zeros(self.N) 
            
            for j in range(0,self.N):
                re_tseries[j]=tseries[j-self.N//2] #rescaled

            self.re_tseries = re_tseries

        def reScale():
            '''
            this function rescales the tseries amplitude to -8191:8191
            '''
            maxVal=np.amax(self.re_tseries)
            minVal=np.amin(self.re_tseries)
            
            #print('maxVal='+str(maxVal))
            #print('minVal='+str(minVal))
            
            N=np.size(self.re_tseries)
            scale=np.zeros(N)
            #rescales amplitude to -8191:8191
            for i in range(0, N):
                scale[i]=int(round((16382*(self.re_tseries[i]-minVal)/(maxVal-minVal))-8191))
            
            self.scale = scale

        
        def writeWF():
            '''
            This function reads out the tscaled spectrum and returns all values of tscaled as a string
            '''
            self.scale = [int(number) for number in self.scale] # redundant to reScale, yes, but necessary for unknown reasons
            logger.info('waveform element numbers of type: '+str(type(self.scale[0])))
            self.msg="DATA:DAC VOLATILE, "
            self.WFstr = ""
            
            N=np.size(self.scale)
            
            for i in range(0, N):
                self.WFstr+=str(int(self.scale[i]))
                if i<N-1:
                    self.WFstr+=", "
            
            self.msg+=self.WFstr 
            self.msg+="\n"
            
            # also partitioning the waveform string into J parts
            J = 4
            K = N//(J-1)     
            self.WFsegs = {"sag_waveform_array_"+str(i): self.scale[i*K:(i+1)*K] for i in range(0,J)} 
            return None
        
        def writeToAG():
            '''
            TCP_IP = a string representing a hostname in Internet domain notation or an IPv4 address
            TCP_PORT = int
            '''
            logger.info('In writeToAG')
            TCP_IP='10.95.101.64'
            TCP_PORT=5025
            BUFFER_SIZE=1024

            s=skt.socket(skt.AF_INET, skt.SOCK_STREAM) #creating a new socket
            s.connect((TCP_IP, TCP_PORT)) #connect to a remote socket at address

            msg3=self.msg
            
            msg2="FREQ 50 \n" #set frequency [Hz]
            s.send(msg2.encode()) # message needs to be encoded as a byte string

            s.send(msg3.encode()) #sends tscaled to the socket
            
            #self.waveform_name = 'MY_AXION4'
            msg="DATA:COPY "+str(self.sag_arb_waveform_name)+"\n" #this saves the name of the line shape to long term memory
            s.send(msg.encode())
            logger.info("messages passed to arb")
            s.close()
            return None
        
        def sendToAG():
            '''
            Iterates over messages to send to waveform generator to update line shape 
            '''
            logger.info('in send to AG')
            values = self.WFsegs
            logger.info('setting waveform array in '+str(len(values))+' segments: '+str(values))
            logger.info('update_waveform_sets: '+str(self.update_waveform_sets))
            self._do_set_collection(self.update_waveform_sets, values)
            logger.info('set complete')
            logger.info('pinging arb for current waveforme stats')
            self.provider.cmd('sag_arb','retrieve_setting',value=[self.sag_arb_waveform_name],timeout=300)
            logger.info('settings retrieved')
            logger.info('instructing sag_arb service to save waveform to {}'.format(self.sag_arb_waveform_name))
            self.provider.cmd('sag_arb','send_waveform',value=[self.sag_arb_waveform_name],timeout=300)
            logger.info('waveform sent')
            return None

        # execute the in-method functions to generate the time series (and load to the waveform generator?)
        #SAG = SAG_Maker(f_stan=self.f_stan, f_rest=self.f_rest, line_shape=self.line_shape)
        get_du()
        SAG_Spec()
        FourierTrans()
        reScale()
        writeWF()
        if self.send_thru_sag_arb_service:
            sendToAG()
        else:
            writeToAG()

        #print('\n--- Waveform of Type '+str(self.line_shape)+' at Center Frequency '+str(self.f_rest)+' Hz Saved as '+str(self.waveform_name)+'---\n', flush=True)

        # self.provider.set('sag_arb_save_waveform',self.tscaled) #this will send this data string to endpoint
        return None




